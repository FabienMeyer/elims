{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#elims","title":"elims","text":""},{"location":"#testing-tools","title":"Testing tools","text":"<ul> <li>uv run ruff check elims/ # Uses [tool.ruff]</li> <li>uv run mypy elims/ # Uses [tool.mypy]</li> <li>uv run mdformat docs/ # Uses [tool.mdformat]</li> <li>uv run vale</li> </ul>"},{"location":"#hooks","title":"Hooks","text":""},{"location":"#install-hooks","title":"Install hooks","text":"<ul> <li>uv run pre-commit install</li> </ul>"},{"location":"#run-on-all-files","title":"Run on all files","text":"<ul> <li>uv run pre-commit run --all-files</li> <li>uv run pre-commit run --files path/to/file.py</li> </ul>"},{"location":"code_of_conduct/","title":"Code of Conduct","text":""},{"location":"code_of_conduct/#code-of-conduct","title":"Code of Conduct","text":""},{"location":"code_of_conduct/#community-pledge","title":"Community Pledge","text":"<p>This community welcomes, protects, and supports all participants.</p> <p>The community fosters an environment that respects and promotes the dignity, rights, and contributions of all individuals, regardless of characteristics including race, ethnicity, caste, color, age, physical characteristics, neurodiversity, disability, sex or gender, gender identity or expression, sexual orientation, language, philosophy or religion, national or social origin, socio-economic position, level of education, or other status. Everyone who participates in good faith receives the same privileges of participation according to this Covenant.</p>"},{"location":"code_of_conduct/#encouraged-behaviors","title":"Encouraged Behaviors","text":"<p>While acknowledging differences in social norms, all participants strive to meet the community's expectations for positive behavior. Everyone understands that words and actions may get interpreted differently than intended based on culture, background, or native language.</p> <p>With these considerations in mind, all participants agree to behave mindfully toward each other and act in ways that center shared values, including:</p> <ol> <li>Respecting the purpose of the community, activities, and ways of gathering.</li> <li>Engaging kindly and honestly with others.</li> <li>Respecting different viewpoints and experiences.</li> <li>Taking responsibility for actions and contributions.</li> <li>Giving and accepting constructive feedback thoughtfully.</li> <li>Committing to repairing harm when it occurs.</li> <li>Behaving in other ways that promote and sustain community well-being.</li> </ol>"},{"location":"code_of_conduct/#restricted-behaviors","title":"Restricted Behaviors","text":"<p>The community restricts the following behaviors. Instances, threats, and promotion of these behaviors violate this Code of Conduct.</p> <ol> <li>Harassment. Violating explicitly expressed boundaries or engaging in unnecessary personal attention after any clear request to stop.</li> <li>Character attacks. Making insulting, demeaning, or pejorative comments directed at a community member or group of people.</li> <li>Stereotyping or discrimination. Characterizing anyone\u2019s personality or behavior on the basis of immutable identities or traits.</li> <li>Sexualization. Behaving in a way that would be considered inappropriately intimate in the context or purpose of the community.</li> <li>Violating confidentiality. Sharing or acting on someone's personal or private information without their permission.</li> <li>Endangerment. Causing, encouraging, or threatening violence or other harm toward any person or group.</li> <li>Behaving in other ways that threaten community well-being.</li> </ol>"},{"location":"code_of_conduct/#other-restrictions","title":"Other Restrictions","text":"<ol> <li>Misleading identity. Impersonating someone else for any reason, or pretending to be someone else to evade enforcement actions.</li> <li>Failing to credit sources. Not crediting the sources of content you contribute.</li> <li>Promotional materials. Sharing marketing or other commercial content in a way that's outside the norms of the community.</li> <li>Irresponsible communication. Failing to responsibly present content which includes, links or describes any other restricted behaviors.</li> </ol>"},{"location":"code_of_conduct/#reporting-an-issue","title":"Reporting an Issue","text":"<p>Tensions can occur between community members even when they're trying their best to collaborate. Not every conflict represents a code of conduct violation, and this Code of Conduct reinforces encouraged behaviors and norms that can help avoid conflicts and minimize harm.</p> <p>When an incident occurs, it's important to report it promptly. To report a possible violation, you can contact GitHub.</p> <p>Community Moderators take reports of violations seriously and respond promptly. They investigate all reports of code of conduct violations, reviewing messages, logs, and recordings, or interviewing witnesses and other participants. Community Moderators keep investigation and enforcement actions as transparent as possible while prioritizing safety and confidentiality. To honor these values, enforcement actions occur in private with the involved parties, but communicating to the whole community may be part of a mutually agreed upon resolution.</p>"},{"location":"code_of_conduct/#addressing-and-repairing-harm","title":"Addressing and Repairing Harm","text":"<p>If an investigation by the Community Moderators finds that someone violated this Code of Conduct, the following enforcement ladder may help determine how best to repair harm, based on the incident's impact on the individuals involved and the community as a whole. Depending on the severity of a violation, lower rungs on the ladder may get skipped.</p> <ol> <li>Warning</li> <li>Event: A violation involving a single incident or series of incidents.</li> <li>Consequence: A private, written warning from the Community Moderators.</li> <li>Repair: Examples of repair include a private written apology, acknowledgement of responsibility, and seeking clarification on expectations.</li> <li>Temporarily Limited Activities</li> <li>Event: A repeated incidence of a violation that resulted in a warning, or the first incidence of a more serious violation.</li> <li>Consequence: A private, written warning with a time-limited cooldown period designed to underscore the seriousness of the situation and give the community members involved time to process the incident. The cooldown period may get limited to particular communication channels or interactions with particular community members.</li> <li>Repair: Examples of repair may include making an apology, using the cooldown period to reflect on actions and impact, and being thoughtful about re-entering community spaces after the period is over.</li> <li>Temporary Suspension</li> <li>Event: A pattern of repeated violation which the Community Moderators have tried to address with warnings, or a single serious violation.</li> <li>Consequence: A private written warning with conditions for return from suspension. In general, temporary suspensions give the person being suspended time to reflect upon their behavior and possible corrective actions.</li> <li>Repair: Examples of repair include respecting the spirit of the suspension, meeting the specified conditions for return, and being thoughtful about how to reintegrate with the community when the suspension is lifted.</li> <li>Permanent Ban</li> <li>Event: A pattern of repeated code of conduct violations that other steps on the ladder have failed to resolve, or a violation so serious that the Community Moderators determine there is no way to keep the community safe with this person as a member.</li> <li>Consequence: Access to all community spaces, tools, and communication channels gets removed. In general, permanent bans should get used rarely, should have strong reasoning behind them, and should only occur if working through other remedies has failed to change the behavior.</li> <li>Repair: No possible repair exists in cases of this severity.</li> </ol> <p>This enforcement ladder serves as a guideline. It doesn't limit the ability of Community Managers to use their discretion and judgment, in keeping with the best interests of the community.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual officially represents the community in public or other spaces. Examples of representing the community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 3.0, permanently available at https://www.contributor-covenant.org/version/3/0/.</p> <p>The Organization for Ethical Source stewards Contributor Covenant and licenses it under CC BY-SA 4.0. To view a copy of this license, visit https://creativecommons.org/licenses/by-sa/4.0/</p> <p>For answers to common questions about Contributor Covenant, see the FAQ at https://www.contributor-covenant.org/faq. Translations are provided at https://www.contributor-covenant.org/translations. Additional enforcement and community guideline resources can be found at https://www.contributor-covenant.org/resources. The enforcement ladder was inspired by the work of Mozilla\u2019s code of conduct team.</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Welcome to the Elims project!</p> <p>Thank you for your interest in contributing to the elims community. The project currently focuses on internal development and doesn't accept code contributions yet. Your enthusiasm and engagement with the project remain valuable.</p>"},{"location":"contributing/#current-status","title":"Current Status","text":"<p>The Elims project is currently in internal development mode.</p>"},{"location":"contributing/#how-you-can-help-right-now","title":"How You Can Help Right Now","text":"<p>Even though pull requests aren't accepted yet, there are specific ways you can support the project:</p>"},{"location":"contributing/#report-issues","title":"Report Issues","text":"<p>Found a bug in the documentation or have a safety concern? Please open an issue with:</p> <ul> <li>Clear description of the problem</li> <li>Steps to reproduce (if applicable)</li> <li>Your environment details (hardware, software versions)</li> <li>Any safety implications</li> </ul>"},{"location":"contributing/#improve-documentation","title":"Improve Documentation","text":"<p>Spot a typo or unclear instruction? Documentation improvements are always welcome through issue reports.</p>"},{"location":"contributing/#elims-community-values","title":"Elims Community Values","text":"<p>All contributors must uphold the Code of Conduct and embrace these community values:</p> <ul> <li>Inclusivity: elims welcomes everyone</li> <li>Knowledge Sharing: Technical knowledge gets shared openly</li> <li>Safety First: Electrical and mechanical safety takes priority</li> </ul>"},{"location":"contributing/#stay-updated","title":"Stay Updated","text":"<p>Star the repository to stay notified of updates and releases</p>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright \u00a9 2025 Fabien</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"privacy/","title":"Privacy","text":""},{"location":"privacy/#privacy","title":"Privacy","text":"<p>Last updated: August 5, 2025</p> <p>This website, Elims Documentation, provides a static site generated using MkDocs and Material for MkDocs. GitHub Pages hosts and publishes the site.</p> <p>This page outlines the minimal data practices of this site and respects your privacy.</p>"},{"location":"privacy/#no-personal-data-collected","title":"No Personal Data Collected","text":"<p>This site doesn't collect, store, or process any personal data.</p> <ul> <li>No contact forms</li> <li>No user accounts</li> <li>No login or registration</li> <li>No tracking cookies or third-party analytics</li> </ul>"},{"location":"privacy/#no-cookies","title":"No Cookies","text":"<p>This site doesn't use any cookies, not for analytics, personalization, or advertising.</p>"},{"location":"privacy/#no-embedded-trackers","title":"No Embedded Trackers","text":"<p>This site doesn't embed or include any scripts from third-party services that track visitors (for example, Google Analytics, Facebook Pixel, etc.).</p> <p>All JavaScript used on this site stays self-hosted and improves the documentation experience (for example, rendering diagrams and charts via <code>Mermaid</code> and <code>Plotly</code>).</p>"},{"location":"privacy/#hosting-and-logs","title":"Hosting and Logs","text":"<p>GitHub Pages hosts this site, a static site hosting service provided by GitHub. GitHub may collect standard web server logs (for example, IP addresses, browser type, referring pages) for operational and security purposes.</p> <p>Please consult GitHub\u2019s Privacy Statement for more details on how GitHub handles such data.</p>"},{"location":"privacy/#external-links","title":"External Links","text":"<p>This documentation may include links to third-party websites (for example, GitHub repositories, hardware data sheets). The site owners bear no responsibility for the privacy policies or practices of those external sites.</p>"},{"location":"privacy/#contact","title":"Contact","text":"<p>If you have any questions or concerns about this privacy policy or the site\u2019s behavior, you may reach out via GitHub.</p>"},{"location":"privacy/#changes-to-this-policy","title":"Changes to This Policy","text":"<p>This privacy policy may need updates to reflect changes in site features or hosting. The site owners will document any updates on this page, with the \"last updated\" date at the top revised accordingly.</p>"},{"location":"api/api/","title":"API","text":""},{"location":"api/api/#api","title":"API","text":""},{"location":"api/api/#elims.api.api","title":"<code>api</code>","text":"<p>FastAPI application for the ELIMS project.</p>"},{"location":"api/api/#elims.api.api.lifespan","title":"<code>lifespan(app)</code>  <code>async</code>","text":"<p>Application lifespan to initialize and tear down resources.</p> Source code in <code>elims/api/api.py</code> <pre><code>@asynccontextmanager\nasync def lifespan(app: FastAPI) -&gt; AsyncGenerator[None]:  # noqa: ARG001 - app required by FastAPI signature\n    \"\"\"Application lifespan to initialize and tear down resources.\"\"\"\n    configure_logging()\n    logger.info(\"Application startup beginning...\")\n    await create_db_and_tables()\n    logger.info(\"Application startup complete.\")\n    yield\n    logger.info(\"Application shutdown complete.\")\n</code></pre>"},{"location":"api/db/","title":"Database","text":""},{"location":"api/db/#database","title":"Database","text":""},{"location":"api/db/#elims.api.db","title":"<code>db</code>","text":"<p>Database module for handling connections and session management.</p>"},{"location":"api/db/#elims.api.db.create_db_and_tables","title":"<code>create_db_and_tables()</code>  <code>async</code>","text":"<p>Initialize the database and create tables asynchronously.</p> Source code in <code>elims/api/db.py</code> <pre><code>async def create_db_and_tables() -&gt; None:\n    \"\"\"Initialize the database and create tables asynchronously.\"\"\"\n    async with engine.begin() as conn:\n        await conn.run_sync(SQLModel.metadata.create_all)\n    logger.info(f\"Database tables created for URL: {base_url}\")\n</code></pre>"},{"location":"api/db/#elims.api.db.get_session","title":"<code>get_session()</code>  <code>async</code>","text":"<p>FastAPI dependency that yields an async database session.</p> Source code in <code>elims/api/db.py</code> <pre><code>async def get_session() -&gt; AsyncGenerator[AsyncSession]:\n    \"\"\"FastAPI dependency that yields an async database session.\"\"\"\n    async with SessionLocal() as session:\n        yield session\n</code></pre>"},{"location":"api/logger/","title":"Logger","text":""},{"location":"api/logger/#logger","title":"Logger","text":""},{"location":"api/logger/#elims.api.logger","title":"<code>logger</code>","text":"<p>Logging configuration for the application.</p>"},{"location":"api/logger/#elims.api.logger.configure_logging","title":"<code>configure_logging()</code>","text":"<p>Configure Loguru for application-wide logging.</p> <p>This setup removes the default handler and adds a new, colorful handler that writes to standard error, optimized for asynchronous environments.</p> Source code in <code>elims/api/logger.py</code> <pre><code>def configure_logging() -&gt; None:\n    \"\"\"Configure Loguru for application-wide logging.\n\n    This setup removes the default handler and adds a new, colorful handler\n    that writes to standard error, optimized for asynchronous environments.\n    \"\"\"\n    logger.remove()\n    logger.add(\n        sys.stderr,\n        level=\"INFO\",\n        format=(\n            \"&lt;green&gt;{time:YYYY-MM-DD HH:mm:ss.SSS}&lt;/green&gt; | \"\n            \"&lt;level&gt;{level: &lt;8}&lt;/level&gt; | \"\n            \"&lt;cyan&gt;{name}&lt;/cyan&gt;:&lt;cyan&gt;{function}&lt;/cyan&gt;:&lt;cyan&gt;{line}&lt;/cyan&gt; - \"\n            \"&lt;level&gt;{message}&lt;/level&gt;\"\n        ),\n        colorize=True,\n        enqueue=True,\n    )\n    logger.info(\"Loguru configured successfully.\")\n</code></pre>"},{"location":"api/routers/","title":"Routers","text":""},{"location":"api/routers/#routers","title":"Routers","text":""},{"location":"api/routers/#elims.api.routers","title":"<code>routers</code>","text":"<p>Main API router for aggregating all module-specific routers.</p>"},{"location":"api/modules/instruments/instruments/","title":"Instruments","text":""},{"location":"api/modules/instruments/instruments/#instruments","title":"Instruments","text":""},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.constants","title":"<code>constants</code>","text":"<p>Constants for the API instruments module.</p>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.constants.ModelStr","title":"<code>ModelStr = Annotated[str, Field(pattern='^[A-Za-z0-9_-]+$')]</code>  <code>module-attribute</code>","text":"<p>Type alias for instrument model strings with validation.</p>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.constants.SerialNumberStr","title":"<code>SerialNumberStr = Annotated[str, Field(pattern='^[A-Za-z0-9_-]+$')]</code>  <code>module-attribute</code>","text":"<p>Type alias for instrument serial number strings with validation.</p>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.constants.InstrumentBrand","title":"<code>InstrumentBrand</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of instrument brands.</p>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.constants.InstrumentBrand.__repr__","title":"<code>__repr__()</code>","text":"<p>Get the official string representation of the instrument brand.</p> Source code in <code>elims/api/modules/instruments/constants.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Get the official string representation of the instrument brand.\"\"\"\n    return f\"{self.name}: {self.value}\"\n</code></pre>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.constants.InstrumentBrand.__str__","title":"<code>__str__()</code>","text":"<p>Get the informal string representation of the instrument brand.</p> Source code in <code>elims/api/modules/instruments/constants.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Get the informal string representation of the instrument brand.\"\"\"\n    return {\n        InstrumentBrand.ANRITSU: \"Anritsu\",\n        InstrumentBrand.KEYSIGHT: \"Keysight\",\n        InstrumentBrand.TELEDYNE_LECROY: \"Teledyne LeCroy\",\n        InstrumentBrand.TEKTRONIX: \"Tektronix\",\n    }[self]\n</code></pre>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.constants.InstrumentBrand.choices","title":"<code>choices()</code>  <code>staticmethod</code>","text":"<p>Get a list of all instrument brand display names.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of strings representing the full names of the brands.</p> Source code in <code>elims/api/modules/instruments/constants.py</code> <pre><code>@staticmethod\ndef choices() -&gt; list[str]:\n    \"\"\"Get a list of all instrument brand display names.\n\n    Returns:\n        A list of strings representing the full names of the brands.\n\n    \"\"\"\n    return [str(instrument_brand) for instrument_brand in InstrumentBrand]\n</code></pre>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.constants.InstrumentType","title":"<code>InstrumentType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of instrument types.</p>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.constants.InstrumentType.__repr__","title":"<code>__repr__()</code>","text":"<p>Get the official string representation of the instrument type.</p> Source code in <code>elims/api/modules/instruments/constants.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Get the official string representation of the instrument type.\"\"\"\n    return f\"{self.name}: {self.value}\"\n</code></pre>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.constants.InstrumentType.__str__","title":"<code>__str__()</code>","text":"<p>Get the informal string representation of the instrument type.</p> Source code in <code>elims/api/modules/instruments/constants.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Get the informal string representation of the instrument type.\"\"\"\n    return {\n        InstrumentType.BIT_ERROR_RATE_TESTER: \"Bit Error Rate Tester\",\n        InstrumentType.DIGITAL_MULTIMETER: \"Digital Multimeter\",\n        InstrumentType.ELECTRICAL_SIGNAL_GENERATOR: \"Electrical Signal Generator\",\n        InstrumentType.OSCILLOSCOPE: \"Oscilloscope\",\n        InstrumentType.POWER_SUPPLY: \"Power Supply\",\n        InstrumentType.SPECTRUM_ANALYZER: \"Spectrum Analyzer\",\n        InstrumentType.TEMPERATURE_UNIT: \"Temperature Unit\",\n        InstrumentType.VECTOR_NETWORK_ANALYZER: \"Vector Network Analyzer\",\n    }[self]\n</code></pre>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.constants.InstrumentType.choices","title":"<code>choices()</code>  <code>staticmethod</code>","text":"<p>Get a list of all instrument type display names.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of strings representing the full names of the types.</p> Source code in <code>elims/api/modules/instruments/constants.py</code> <pre><code>@staticmethod\ndef choices() -&gt; list[str]:\n    \"\"\"Get a list of all instrument type display names.\n\n    Returns:\n        A list of strings representing the full names of the types.\n\n    \"\"\"\n    return [str(instrument_type) for instrument_type in InstrumentType]\n</code></pre>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.exceptions","title":"<code>exceptions</code>","text":"<p>Exceptions for the API instruments module.</p>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.exceptions.InstrumentAlreadyExistError","title":"<code>InstrumentAlreadyExistError(serial_number)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when an instrument with a given serial number already exists.</p> <p>Initialize the exception.</p> <p>Parameters:</p> Name Type Description Default <code>serial_number</code> <code>str</code> <p>The serial number that already exists.</p> required Source code in <code>elims/api/modules/instruments/exceptions.py</code> <pre><code>def __init__(self, serial_number: str) -&gt; None:\n    \"\"\"Initialize the exception.\n\n    Args:\n        serial_number: The serial number that already exists.\n\n    \"\"\"\n    super().__init__(f\"Instrument with serial number '{serial_number}' already exists.\")\n</code></pre>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.exceptions.InstrumentBrandError","title":"<code>InstrumentBrandError(value)</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Exception raised for an invalid instrument brand.</p> <p>Initialize the exception.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The invalid brand value that was provided.</p> required Source code in <code>elims/api/modules/instruments/exceptions.py</code> <pre><code>def __init__(self, value: str) -&gt; None:\n    \"\"\"Initialize the exception.\n\n    Args:\n        value: The invalid brand value that was provided.\n\n    \"\"\"\n    message = f\"Invalid instrument brand: '{value}'. Allowed: {', '.join(InstrumentBrand.choices())}.\"\n    super().__init__(message)\n</code></pre>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.exceptions.InstrumentNotFoundError","title":"<code>InstrumentNotFoundError(instrument_id)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when an instrument is not found in the database.</p> <p>Initialize the exception.</p> <p>Parameters:</p> Name Type Description Default <code>instrument_id</code> <code>int</code> <p>The ID of the instrument that was not found.</p> required Source code in <code>elims/api/modules/instruments/exceptions.py</code> <pre><code>def __init__(self, instrument_id: int) -&gt; None:\n    \"\"\"Initialize the exception.\n\n    Args:\n        instrument_id: The ID of the instrument that was not found.\n\n    \"\"\"\n    super().__init__(f\"Instrument with ID {instrument_id} not found.\")\n</code></pre>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.exceptions.InstrumentTypeError","title":"<code>InstrumentTypeError(value)</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Exception raised for an invalid instrument type.</p> <p>Initialize the exception.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The invalid type value that was provided.</p> required Source code in <code>elims/api/modules/instruments/exceptions.py</code> <pre><code>def __init__(self, value: str) -&gt; None:\n    \"\"\"Initialize the exception.\n\n    Args:\n        value: The invalid type value that was provided.\n\n    \"\"\"\n    message = f\"Invalid instrument type: '{value}'. Allowed: {', '.join(InstrumentType.choices())}.\"\n    super().__init__(message)\n</code></pre>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.models","title":"<code>models</code>","text":"<p>Models for the API instruments module.</p>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.models.Instrument","title":"<code>Instrument</code>","text":"<p>               Bases: <code>InstrumentBase</code></p> <p>Represents an instrument in the database.</p> <p>This model is used for database interactions (creation, retrieval, updates) and corresponds to the 'instrument' table.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>The primary key of the instrument in the database.</p> <code>serial_number</code> <code>SerialNumberStr</code> <p>The unique serial number of the instrument.</p>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.routes","title":"<code>routes</code>","text":"<p>API routes for the API instruments module.</p>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.routes.create_instrument","title":"<code>create_instrument(instrument_data, service)</code>  <code>async</code>","text":"<p>Create a new instrument.</p> <p>Parameters:</p> Name Type Description Default <code>instrument_data</code> <code>InstrumentCreate</code> <p>The instrument data for creation.</p> required <code>service</code> <code>Annotated[InstrumentService, Depends(get_instrument_service)]</code> <p>The instrument service dependency.</p> required <p>Returns:</p> Type Description <code>InstrumentRead</code> <p>The created instrument with its database ID.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If an instrument with the same serial number already exists.</p> Source code in <code>elims/api/modules/instruments/routes.py</code> <pre><code>@router_resource.post(\"/\", status_code=status.HTTP_201_CREATED)\nasync def create_instrument(\n    instrument_data: InstrumentCreate,\n    service: Annotated[InstrumentService, Depends(get_instrument_service)],\n) -&gt; InstrumentRead:\n    \"\"\"Create a new instrument.\n\n    Args:\n        instrument_data: The instrument data for creation.\n        service: The instrument service dependency.\n\n    Returns:\n        The created instrument with its database ID.\n\n    Raises:\n        HTTPException: If an instrument with the same serial number already exists.\n\n    \"\"\"\n    try:\n        return await service.create(instrument_data)\n    except InstrumentAlreadyExistError as e:\n        detail = str(e)\n        logger.warning(f\"Create instrument failed due to conflict: {detail}\")\n        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=detail) from e\n</code></pre>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.routes.delete_instrument","title":"<code>delete_instrument(instrument_id, service)</code>  <code>async</code>","text":"<p>Delete an instrument by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>instrument_id</code> <code>int</code> <p>The ID of the instrument to delete.</p> required <code>service</code> <code>Annotated[InstrumentService, Depends(get_instrument_service)]</code> <p>The instrument service dependency.</p> required <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the instrument is not found.</p> Source code in <code>elims/api/modules/instruments/routes.py</code> <pre><code>@router_resource.delete(\"/{instrument_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_instrument(\n    instrument_id: int,\n    service: Annotated[InstrumentService, Depends(get_instrument_service)],\n) -&gt; None:\n    \"\"\"Delete an instrument by its ID.\n\n    Args:\n        instrument_id: The ID of the instrument to delete.\n        service: The instrument service dependency.\n\n    Raises:\n        HTTPException: If the instrument is not found.\n\n    \"\"\"\n    try:\n        await service.delete(instrument_id)\n    except InstrumentNotFoundError as e:\n        detail = str(e)\n        logger.warning(f\"Delete instrument failed: {detail}\")\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=detail) from e\n</code></pre>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.routes.get_instrument","title":"<code>get_instrument(instrument_id, service)</code>  <code>async</code>","text":"<p>Get an instrument by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>instrument_id</code> <code>int</code> <p>The ID of the instrument to retrieve.</p> required <code>service</code> <code>Annotated[InstrumentService, Depends(get_instrument_service)]</code> <p>The instrument service dependency.</p> required <p>Returns:</p> Type Description <code>InstrumentRead</code> <p>The requested instrument.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the instrument is not found.</p> Source code in <code>elims/api/modules/instruments/routes.py</code> <pre><code>@router_resource.get(\"/{instrument_id}\")\nasync def get_instrument(\n    instrument_id: int,\n    service: Annotated[InstrumentService, Depends(get_instrument_service)],\n) -&gt; InstrumentRead:\n    \"\"\"Get an instrument by its ID.\n\n    Args:\n        instrument_id: The ID of the instrument to retrieve.\n        service: The instrument service dependency.\n\n    Returns:\n        The requested instrument.\n\n    Raises:\n        HTTPException: If the instrument is not found.\n\n    \"\"\"\n    try:\n        return await service.get(instrument_id)\n    except InstrumentNotFoundError as e:\n        detail = str(e)\n        logger.warning(f\"Get instrument failed: {detail}\")\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=detail) from e\n</code></pre>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.routes.get_instrument_service","title":"<code>get_instrument_service(session)</code>  <code>async</code>","text":"<p>Instantiate and provide the InstrumentService.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Annotated[AsyncSession, Depends(get_session)]</code> <p>The asynchronous database session.</p> required <p>Returns:</p> Type Description <code>InstrumentService</code> <p>An instance of InstrumentService.</p> Source code in <code>elims/api/modules/instruments/routes.py</code> <pre><code>async def get_instrument_service(\n    session: Annotated[AsyncSession, Depends(get_session)],\n) -&gt; InstrumentService:\n    \"\"\"Instantiate and provide the InstrumentService.\n\n    Args:\n        session: The asynchronous database session.\n\n    Returns:\n        An instance of InstrumentService.\n\n    \"\"\"\n    return InstrumentService(session=session)\n</code></pre>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.routes.gets_instruments","title":"<code>gets_instruments(service)</code>  <code>async</code>","text":"<p>List all instruments.</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>Annotated[InstrumentService, Depends(get_instrument_service)]</code> <p>The instrument service dependency.</p> required <p>Returns:</p> Type Description <code>list[InstrumentRead]</code> <p>A list of all instruments.</p> Source code in <code>elims/api/modules/instruments/routes.py</code> <pre><code>@router_collection.get(\"/\")\nasync def gets_instruments(\n    service: Annotated[InstrumentService, Depends(get_instrument_service)],\n) -&gt; list[InstrumentRead]:\n    \"\"\"List all instruments.\n\n    Args:\n        service: The instrument service dependency.\n\n    Returns:\n        A list of all instruments.\n\n    \"\"\"\n    return await service.gets()\n</code></pre>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.routes.update_instrument","title":"<code>update_instrument(instrument_id, instrument_data, service)</code>  <code>async</code>","text":"<p>Update an instrument (partial update).</p> <p>Parameters:</p> Name Type Description Default <code>instrument_id</code> <code>int</code> <p>The ID of the instrument to update.</p> required <code>instrument_data</code> <code>InstrumentUpdate</code> <p>The instrument data to update (only provided fields are updated).</p> required <code>service</code> <code>Annotated[InstrumentService, Depends(get_instrument_service)]</code> <p>The instrument service dependency.</p> required <p>Returns:</p> Type Description <code>InstrumentRead</code> <p>The updated instrument.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the instrument is not found or a conflict occurs.</p> Source code in <code>elims/api/modules/instruments/routes.py</code> <pre><code>@router_resource.patch(\"/{instrument_id}\")\nasync def update_instrument(\n    instrument_id: int,\n    instrument_data: InstrumentUpdate,\n    service: Annotated[InstrumentService, Depends(get_instrument_service)],\n) -&gt; InstrumentRead:\n    \"\"\"Update an instrument (partial update).\n\n    Args:\n        instrument_id: The ID of the instrument to update.\n        instrument_data: The instrument data to update (only provided fields are updated).\n        service: The instrument service dependency.\n\n    Returns:\n        The updated instrument.\n\n    Raises:\n        HTTPException: If the instrument is not found or a conflict occurs.\n\n    \"\"\"\n    try:\n        return await service.update(instrument_id, instrument_data)\n    except InstrumentNotFoundError as e:\n        detail = str(e)\n        logger.warning(f\"Update instrument failed, not found: {detail}\")\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=detail) from e\n    except InstrumentAlreadyExistError as e:\n        detail = str(e)\n        logger.warning(f\"Update instrument failed, conflict: {detail}\")\n        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=detail) from e\n</code></pre>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.schemas","title":"<code>schemas</code>","text":"<p>Schemas for the API instruments module.</p>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.schemas.InstrumentBase","title":"<code>InstrumentBase</code>","text":"<p>               Bases: <code>SQLModel</code></p> <p>Base schema for an instrument with shared fields and validation.</p>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.schemas.InstrumentBase.validate_brand","title":"<code>validate_brand(value)</code>  <code>classmethod</code>","text":"<p>Validate and convert the brand value to an InstrumentBrand enum.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str | InstrumentBrand</code> <p>The input value, which can be a string or InstrumentBrand.</p> required <p>Returns:</p> Type Description <code>InstrumentBrand</code> <p>The corresponding InstrumentBrand enum member.</p> <p>Raises:</p> Type Description <code>InstrumentBrandError</code> <p>If the value is not a valid brand.</p> Source code in <code>elims/api/modules/instruments/schemas.py</code> <pre><code>@field_validator(\"brand\", mode=\"before\")\n@classmethod\ndef validate_brand(cls, value: str | InstrumentBrand) -&gt; InstrumentBrand:\n    \"\"\"Validate and convert the brand value to an InstrumentBrand enum.\n\n    Args:\n        value: The input value, which can be a string or InstrumentBrand.\n\n    Returns:\n        The corresponding InstrumentBrand enum member.\n\n    Raises:\n        InstrumentBrandError: If the value is not a valid brand.\n\n    \"\"\"\n    if isinstance(value, InstrumentBrand):\n        return value\n    try:\n        return InstrumentBrand(value)\n    except ValueError as e:\n        raise InstrumentBrandError(str(value)) from e\n</code></pre>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.schemas.InstrumentBase.validate_type","title":"<code>validate_type(value)</code>  <code>classmethod</code>","text":"<p>Validate and convert the type value to an InstrumentType enum.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str | InstrumentType</code> <p>The input value, which can be a string or InstrumentType.</p> required <p>Returns:</p> Type Description <code>InstrumentType</code> <p>The corresponding InstrumentType enum member.</p> <p>Raises:</p> Type Description <code>InstrumentTypeError</code> <p>If the value is not a valid type.</p> Source code in <code>elims/api/modules/instruments/schemas.py</code> <pre><code>@field_validator(\"type\", mode=\"before\")\n@classmethod\ndef validate_type(cls, value: str | InstrumentType) -&gt; InstrumentType:\n    \"\"\"Validate and convert the type value to an InstrumentType enum.\n\n    Args:\n        value: The input value, which can be a string or InstrumentType.\n\n    Returns:\n        The corresponding InstrumentType enum member.\n\n    Raises:\n        InstrumentTypeError: If the value is not a valid type.\n\n    \"\"\"\n    if isinstance(value, InstrumentType):\n        return value\n    try:\n        return InstrumentType(value)\n    except ValueError as e:\n        raise InstrumentTypeError(str(value)) from e\n</code></pre>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.schemas.InstrumentCreate","title":"<code>InstrumentCreate</code>","text":"<p>               Bases: <code>InstrumentBase</code></p> <p>Schema for creating a new instrument (API input).</p>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.schemas.InstrumentRead","title":"<code>InstrumentRead</code>","text":"<p>               Bases: <code>InstrumentBase</code></p> <p>Schema for representing a read-only instrument (API output).</p> <p>Includes the database-generated ID.</p>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.schemas.InstrumentUpdate","title":"<code>InstrumentUpdate</code>","text":"<p>               Bases: <code>SQLModel</code></p> <p>Schema for updating an existing instrument (API input).</p> <p>All fields are optional to allow for partial updates.</p>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.schemas.InstrumentUpdate.validate_brand","title":"<code>validate_brand(value)</code>  <code>classmethod</code>","text":"<p>Validate and convert the brand value to an InstrumentBrand enum.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str | InstrumentBrand | None</code> <p>The input value, which can be a string or InstrumentBrand.</p> required <p>Returns:</p> Type Description <code>InstrumentBrand | None</code> <p>The corresponding InstrumentBrand enum member.</p> <p>Raises:</p> Type Description <code>InstrumentBrandError</code> <p>If the value is not a valid brand.</p> Source code in <code>elims/api/modules/instruments/schemas.py</code> <pre><code>@field_validator(\"brand\", mode=\"before\")\n@classmethod\ndef validate_brand(cls, value: str | InstrumentBrand | None) -&gt; InstrumentBrand | None:\n    \"\"\"Validate and convert the brand value to an InstrumentBrand enum.\n\n    Args:\n        value: The input value, which can be a string or InstrumentBrand.\n\n    Returns:\n        The corresponding InstrumentBrand enum member.\n\n    Raises:\n        InstrumentBrandError: If the value is not a valid brand.\n\n    \"\"\"\n    if isinstance(value, InstrumentBrand) or value is None:\n        return value\n    try:\n        return InstrumentBrand(value)\n    except ValueError as e:\n        raise InstrumentBrandError(str(value)) from e\n</code></pre>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.schemas.InstrumentUpdate.validate_type","title":"<code>validate_type(value)</code>  <code>classmethod</code>","text":"<p>Validate and convert the type value to an InstrumentType enum.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str | InstrumentType | None</code> <p>The input value, which can be a string or InstrumentType.</p> required <p>Returns:</p> Type Description <code>InstrumentType | None</code> <p>The corresponding InstrumentType enum member.</p> <p>Raises:</p> Type Description <code>InstrumentTypeError</code> <p>If the value is not a valid type.</p> Source code in <code>elims/api/modules/instruments/schemas.py</code> <pre><code>@field_validator(\"type\", mode=\"before\")\n@classmethod\ndef validate_type(cls, value: str | InstrumentType | None) -&gt; InstrumentType | None:\n    \"\"\"Validate and convert the type value to an InstrumentType enum.\n\n    Args:\n        value: The input value, which can be a string or InstrumentType.\n\n    Returns:\n        The corresponding InstrumentType enum member.\n\n    Raises:\n        InstrumentTypeError: If the value is not a valid type.\n\n    \"\"\"\n    if isinstance(value, InstrumentType) or value is None:\n        return value\n    try:\n        return InstrumentType(value)\n    except ValueError as e:\n        raise InstrumentTypeError(str(value)) from e\n</code></pre>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.services","title":"<code>services</code>","text":"<p>Services for the API instruments module.</p>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.services.InstrumentService","title":"<code>InstrumentService(session)</code>","text":"<p>Encapsulates CRUD operations for the Instrument model.</p> <p>Initialize the service with an async database session.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AsyncSession</code> <p>The asynchronous database session.</p> required Source code in <code>elims/api/modules/instruments/services.py</code> <pre><code>def __init__(self, session: AsyncSession) -&gt; None:\n    \"\"\"Initialize the service with an async database session.\n\n    Args:\n        session: The asynchronous database session.\n\n    \"\"\"\n    self.session = session\n    logger.debug(f\"InstrumentService initialized with async session: {session}\")\n</code></pre>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.services.InstrumentService.create","title":"<code>create(instrument_data)</code>  <code>async</code>","text":"<p>Create a new instrument in the database.</p> <p>Parameters:</p> Name Type Description Default <code>instrument_data</code> <code>InstrumentCreate</code> <p>The data for the new instrument.</p> required <p>Returns:</p> Type Description <code>InstrumentRead</code> <p>The newly created instrument with its database ID.</p> <p>Raises:</p> Type Description <code>InstrumentAlreadyExistError</code> <p>If an instrument with the same serial number already exists.</p> Source code in <code>elims/api/modules/instruments/services.py</code> <pre><code>async def create(self, instrument_data: InstrumentCreate) -&gt; InstrumentRead:\n    \"\"\"Create a new instrument in the database.\n\n    Args:\n        instrument_data: The data for the new instrument.\n\n    Returns:\n        The newly created instrument with its database ID.\n\n    Raises:\n        InstrumentAlreadyExistError: If an instrument with the same\n            serial number already exists.\n\n    \"\"\"\n    try:\n        instrument = Instrument.model_validate(instrument_data)\n        self.session.add(instrument)\n        await self.session.commit()\n        await self.session.refresh(instrument)\n        logger.info(f\"Created instrument with serial number: {instrument.serial_number}\")\n        return InstrumentRead.model_validate(instrument)\n    except IntegrityError as e:\n        await self.session.rollback()\n        logger.error(f\"Failed to create instrument: {e}\")\n        raise InstrumentAlreadyExistError(instrument_data.serial_number) from e\n</code></pre>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.services.InstrumentService.delete","title":"<code>delete(instrument_id)</code>  <code>async</code>","text":"<p>Delete an instrument by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>instrument_id</code> <code>int</code> <p>The ID of the instrument to delete.</p> required <p>Raises:</p> Type Description <code>InstrumentNotFoundError</code> <p>If the instrument is not found.</p> Source code in <code>elims/api/modules/instruments/services.py</code> <pre><code>async def delete(self, instrument_id: int) -&gt; None:\n    \"\"\"Delete an instrument by its ID.\n\n    Args:\n        instrument_id: The ID of the instrument to delete.\n\n    Raises:\n        InstrumentNotFoundError: If the instrument is not found.\n\n    \"\"\"\n    query = select(Instrument).where(Instrument.id == instrument_id)\n    result = await self.session.exec(query)\n    instrument = result.one_or_none()\n    if not instrument:\n        logger.warning(f\"Instrument with ID {instrument_id} not found for deletion\")\n        raise InstrumentNotFoundError(instrument_id)\n\n    await self.session.delete(instrument)\n    await self.session.commit()\n    logger.info(f\"Deleted instrument with ID {instrument_id}\")\n</code></pre>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.services.InstrumentService.get","title":"<code>get(instrument_id)</code>  <code>async</code>","text":"<p>Retrieve an instrument by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>instrument_id</code> <code>int</code> <p>The ID of the instrument to retrieve.</p> required <p>Returns:</p> Type Description <code>InstrumentRead</code> <p>The instrument if found.</p> <p>Raises:</p> Type Description <code>InstrumentNotFoundError</code> <p>If the instrument is not found.</p> Source code in <code>elims/api/modules/instruments/services.py</code> <pre><code>async def get(self, instrument_id: int) -&gt; InstrumentRead:\n    \"\"\"Retrieve an instrument by its ID.\n\n    Args:\n        instrument_id: The ID of the instrument to retrieve.\n\n    Returns:\n        The instrument if found.\n\n    Raises:\n        InstrumentNotFoundError: If the instrument is not found.\n\n    \"\"\"\n    query = select(Instrument).where(Instrument.id == instrument_id)\n    result = await self.session.exec(query)\n    instrument = result.one_or_none()\n    if not instrument:\n        logger.warning(f\"Instrument with ID {instrument_id} not found\")\n        raise InstrumentNotFoundError(instrument_id)\n    logger.debug(f\"Retrieved instrument with ID {instrument_id}\")\n    return InstrumentRead.model_validate(instrument)\n</code></pre>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.services.InstrumentService.gets","title":"<code>gets()</code>  <code>async</code>","text":"<p>Retrieve all instruments from the database.</p> <p>Returns:</p> Type Description <code>list[InstrumentRead]</code> <p>A list of all instruments.</p> Source code in <code>elims/api/modules/instruments/services.py</code> <pre><code>async def gets(self) -&gt; list[InstrumentRead]:\n    \"\"\"Retrieve all instruments from the database.\n\n    Returns:\n        A list of all instruments.\n\n    \"\"\"\n    query = select(Instrument)\n    result = await self.session.exec(query)\n    instruments = result.all()\n    logger.debug(f\"Retrieved {len(instruments)} instruments\")\n    return [InstrumentRead.model_validate(instrument) for instrument in instruments]\n</code></pre>"},{"location":"api/modules/instruments/instruments/#elims.api.modules.instruments.services.InstrumentService.update","title":"<code>update(instrument_id, instrument_data)</code>  <code>async</code>","text":"<p>Update an existing instrument.</p> <p>Parameters:</p> Name Type Description Default <code>instrument_id</code> <code>int</code> <p>The ID of the instrument to update.</p> required <code>instrument_data</code> <code>InstrumentUpdate</code> <p>The new data for the instrument (partial updates allowed).</p> required <p>Returns:</p> Type Description <code>InstrumentRead</code> <p>The updated instrument.</p> <p>Raises:</p> Type Description <code>InstrumentNotFoundError</code> <p>If the instrument is not found.</p> <code>InstrumentAlreadyExistError</code> <p>If the serial number is changed to one that already exists.</p> Source code in <code>elims/api/modules/instruments/services.py</code> <pre><code>async def update(self, instrument_id: int, instrument_data: InstrumentUpdate) -&gt; InstrumentRead:\n    \"\"\"Update an existing instrument.\n\n    Args:\n        instrument_id: The ID of the instrument to update.\n        instrument_data: The new data for the instrument (partial updates allowed).\n\n    Returns:\n        The updated instrument.\n\n    Raises:\n        InstrumentNotFoundError: If the instrument is not found.\n        InstrumentAlreadyExistError: If the serial number is changed to one\n            that already exists.\n\n    \"\"\"\n    query = select(Instrument).where(Instrument.id == instrument_id)\n    result = await self.session.exec(query)\n    db_instrument = result.one_or_none()\n    if not db_instrument:\n        logger.warning(f\"Instrument with ID {instrument_id} not found for update\")\n        raise InstrumentNotFoundError(instrument_id)\n\n    # Update only the fields that were provided\n    update_data = instrument_data.model_dump(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(db_instrument, key, value)\n\n    try:\n        self.session.add(db_instrument)\n        await self.session.commit()\n        await self.session.refresh(db_instrument)\n        logger.info(f\"Updated instrument with ID {instrument_id}\")\n        return InstrumentRead.model_validate(db_instrument)\n    except IntegrityError as e:\n        await self.session.rollback()\n        logger.error(f\"Failed to update instrument with ID {instrument_id}: {e}\")\n        raise InstrumentAlreadyExistError(db_instrument.serial_number) from e\n</code></pre>"},{"location":"api/modules/locations/locations/","title":"Locations","text":""},{"location":"api/modules/locations/locations/#locations","title":"Locations","text":""},{"location":"api/modules/locations/locations/#elims.api.modules.locations.constants","title":"<code>constants</code>","text":"<p>Constants for the API locations module.</p>"},{"location":"api/modules/locations/locations/#elims.api.modules.locations.constants.AddressStr","title":"<code>AddressStr = Annotated[str, Field(min_length=2, max_length=200, pattern=\"^[A-Za-z0-9\\\\s,.'-]+$\")]</code>  <code>module-attribute</code>","text":"<p>Type alias for address strings with validation.</p>"},{"location":"api/modules/locations/locations/#elims.api.modules.locations.constants.CityStr","title":"<code>CityStr = Annotated[str, Field(min_length=2, max_length=85, pattern=\"^[A-Za-z\\\\s'-]+$\")]</code>  <code>module-attribute</code>","text":"<p>Type alias for city strings with validation.</p>"},{"location":"api/modules/locations/locations/#elims.api.modules.locations.constants.CountryStr","title":"<code>CountryStr = Annotated[str, Field(min_length=2, max_length=31, pattern=\"^[A-Za-z\\\\s'-]+$\")]</code>  <code>module-attribute</code>","text":"<p>Type alias for country strings with validation.</p>"},{"location":"api/modules/locations/locations/#elims.api.modules.locations.constants.PostalCodeStr","title":"<code>PostalCodeStr = Annotated[str, Field(min_length=2, max_length=10, pattern='^[0-9-]+$')]</code>  <code>module-attribute</code>","text":"<p>Type alias for postal code strings with validation.</p>"},{"location":"api/modules/locations/locations/#elims.api.modules.locations.constants.StateStr","title":"<code>StateStr = Annotated[str, Field(min_length=2, max_length=30, pattern=\"^[A-Za-z\u00c0-\u00ff\\\\s'-]+$\")]</code>  <code>module-attribute</code>","text":"<p>Type alias for state strings with validation.</p>"},{"location":"api/modules/locations/locations/#elims.api.modules.locations.exceptions","title":"<code>exceptions</code>","text":"<p>Exceptions for the API locations module.</p>"},{"location":"api/modules/locations/locations/#elims.api.modules.locations.exceptions.LocationAlreadyExistError","title":"<code>LocationAlreadyExistError(name)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when a location with a given name already exists.</p> <p>Initialize the exception.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name that already exists.</p> required Source code in <code>elims/api/modules/locations/exceptions.py</code> <pre><code>def __init__(self, name: str) -&gt; None:\n    \"\"\"Initialize the exception.\n\n    Args:\n        name: The name that already exists.\n\n    \"\"\"\n    super().__init__(f\"Location with name '{name}' already exists.\")\n</code></pre>"},{"location":"api/modules/locations/locations/#elims.api.modules.locations.exceptions.LocationNotFoundError","title":"<code>LocationNotFoundError(location_id)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when a location is not found in the database.</p> <p>Initialize the exception.</p> <p>Parameters:</p> Name Type Description Default <code>location_id</code> <code>int</code> <p>The ID of the location that was not found.</p> required Source code in <code>elims/api/modules/locations/exceptions.py</code> <pre><code>def __init__(self, location_id: int) -&gt; None:\n    \"\"\"Initialize the exception.\n\n    Args:\n        location_id: The ID of the location that was not found.\n\n    \"\"\"\n    super().__init__(f\"Location with ID {location_id} not found.\")\n</code></pre>"},{"location":"api/modules/locations/locations/#elims.api.modules.locations.models","title":"<code>models</code>","text":"<p>Models for the API locations module.</p>"},{"location":"api/modules/locations/locations/#elims.api.modules.locations.models.Location","title":"<code>Location</code>","text":"<p>               Bases: <code>LocationBase</code></p> <p>Represents a physical laboratory location in the database.</p> <p>This model is used for database interactions (creation, retrieval, updates) and corresponds to the 'location' table.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int | None</code> <p>The primary key of the location in the database.</p> <code>address</code> <code>AddressStr</code> <p>The physical address of the location.</p> <code>city</code> <code>CityStr</code> <p>The city where the location is situated.</p> <code>country</code> <code>CountryStr</code> <p>The country where the location is situated.</p>"},{"location":"api/modules/locations/locations/#elims.api.modules.locations.routes","title":"<code>routes</code>","text":"<p>API routes for the API locations module.</p>"},{"location":"api/modules/locations/locations/#elims.api.modules.locations.routes.create_location","title":"<code>create_location(location_data, service)</code>  <code>async</code>","text":"<p>Create a new location.</p> <p>Parameters:</p> Name Type Description Default <code>location_data</code> <code>LocationCreate</code> <p>The location data for creation.</p> required <code>service</code> <code>Annotated[LocationService, Depends(get_location_service)]</code> <p>The location service dependency.</p> required <p>Returns:</p> Type Description <code>LocationRead</code> <p>The created location with its database ID.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If a location with the same name already exists.</p> Source code in <code>elims/api/modules/locations/routes.py</code> <pre><code>@router_resource.post(\"/\", status_code=status.HTTP_201_CREATED)\nasync def create_location(\n    location_data: LocationCreate,\n    service: Annotated[LocationService, Depends(get_location_service)],\n) -&gt; LocationRead:\n    \"\"\"Create a new location.\n\n    Args:\n        location_data: The location data for creation.\n        service: The location service dependency.\n\n    Returns:\n        The created location with its database ID.\n\n    Raises:\n        HTTPException: If a location with the same name already exists.\n\n    \"\"\"\n    try:\n        return await service.create(location_data)\n    except LocationAlreadyExistError as e:\n        detail = str(e)\n        logger.warning(f\"Create location failed: {detail}\")\n        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=detail) from e\n</code></pre>"},{"location":"api/modules/locations/locations/#elims.api.modules.locations.routes.delete_location","title":"<code>delete_location(location_id, service)</code>  <code>async</code>","text":"<p>Delete a location by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>location_id</code> <code>int</code> <p>The ID of the location to delete.</p> required <code>service</code> <code>Annotated[LocationService, Depends(get_location_service)]</code> <p>The location service dependency.</p> required <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the location is not found.</p> Source code in <code>elims/api/modules/locations/routes.py</code> <pre><code>@router_resource.delete(\"/{location_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_location(\n    location_id: int,\n    service: Annotated[LocationService, Depends(get_location_service)],\n) -&gt; None:\n    \"\"\"Delete a location by its ID.\n\n    Args:\n        location_id: The ID of the location to delete.\n        service: The location service dependency.\n\n    Raises:\n        HTTPException: If the location is not found.\n\n    \"\"\"\n    try:\n        await service.delete(location_id)\n    except LocationNotFoundError as e:\n        detail = str(e)\n        logger.warning(f\"Delete location failed: {detail}\")\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=detail) from e\n</code></pre>"},{"location":"api/modules/locations/locations/#elims.api.modules.locations.routes.get_location","title":"<code>get_location(location_id, service)</code>  <code>async</code>","text":"<p>Retrieve a location by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>location_id</code> <code>int</code> <p>The ID of the location to retrieve.</p> required <code>service</code> <code>Annotated[LocationService, Depends(get_location_service)]</code> <p>The location service dependency.</p> required <p>Returns:</p> Type Description <code>LocationRead</code> <p>The requested location.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the location is not found.</p> Source code in <code>elims/api/modules/locations/routes.py</code> <pre><code>@router_resource.get(\"/{location_id}\")\nasync def get_location(\n    location_id: int,\n    service: Annotated[LocationService, Depends(get_location_service)],\n) -&gt; LocationRead:\n    \"\"\"Retrieve a location by its ID.\n\n    Args:\n        location_id: The ID of the location to retrieve.\n        service: The location service dependency.\n\n    Returns:\n        The requested location.\n\n    Raises:\n        HTTPException: If the location is not found.\n\n    \"\"\"\n    try:\n        return await service.get(location_id)\n    except LocationNotFoundError as e:\n        detail = str(e)\n        logger.warning(f\"Get location failed: {detail}\")\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=detail) from e\n</code></pre>"},{"location":"api/modules/locations/locations/#elims.api.modules.locations.routes.get_location_service","title":"<code>get_location_service(session)</code>  <code>async</code>","text":"<p>Instantiate and provide the LocationService.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Annotated[AsyncSession, Depends(get_session)]</code> <p>The asynchronous database session.</p> required <p>Returns:</p> Type Description <code>LocationService</code> <p>An instance of LocationService.</p> Source code in <code>elims/api/modules/locations/routes.py</code> <pre><code>async def get_location_service(\n    session: Annotated[AsyncSession, Depends(get_session)],\n) -&gt; LocationService:\n    \"\"\"Instantiate and provide the LocationService.\n\n    Args:\n        session: The asynchronous database session.\n\n    Returns:\n        An instance of LocationService.\n\n    \"\"\"\n    return LocationService(session=session)\n</code></pre>"},{"location":"api/modules/locations/locations/#elims.api.modules.locations.routes.get_locations","title":"<code>get_locations(service)</code>  <code>async</code>","text":"<p>Retrieve all locations.</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>Annotated[LocationService, Depends(get_location_service)]</code> <p>The location service dependency.</p> required <p>Returns:</p> Type Description <code>list[LocationRead]</code> <p>A list of all locations.</p> Source code in <code>elims/api/modules/locations/routes.py</code> <pre><code>@router_collection.get(\"/\")\nasync def get_locations(\n    service: Annotated[LocationService, Depends(get_location_service)],\n) -&gt; list[LocationRead]:\n    \"\"\"Retrieve all locations.\n\n    Args:\n        service: The location service dependency.\n\n    Returns:\n        A list of all locations.\n\n    \"\"\"\n    return await service.gets()\n</code></pre>"},{"location":"api/modules/locations/locations/#elims.api.modules.locations.routes.update_location","title":"<code>update_location(location_id, location_data, service)</code>  <code>async</code>","text":"<p>Update an existing location.</p> <p>Parameters:</p> Name Type Description Default <code>location_id</code> <code>int</code> <p>The ID of the location to update.</p> required <code>location_data</code> <code>LocationUpdate</code> <p>The updated location data.</p> required <code>service</code> <code>Annotated[LocationService, Depends(get_location_service)]</code> <p>The location service dependency.</p> required <p>Returns:</p> Type Description <code>LocationRead</code> <p>The updated location.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the location is not found or if a location with the same name already exists.</p> Source code in <code>elims/api/modules/locations/routes.py</code> <pre><code>@router_resource.patch(\"/{location_id}\")\nasync def update_location(\n    location_id: int,\n    location_data: LocationUpdate,\n    service: Annotated[LocationService, Depends(get_location_service)],\n) -&gt; LocationRead:\n    \"\"\"Update an existing location.\n\n    Args:\n        location_id: The ID of the location to update.\n        location_data: The updated location data.\n        service: The location service dependency.\n\n    Returns:\n        The updated location.\n\n    Raises:\n        HTTPException: If the location is not found or if a location\n            with the same name already exists.\n\n    \"\"\"\n    try:\n        return await service.update(location_id, location_data)\n    except LocationNotFoundError as e:\n        detail = str(e)\n        logger.warning(f\"Update location failed: {detail}\")\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=detail) from e\n    except LocationAlreadyExistError as e:\n        detail = str(e)\n        logger.warning(f\"Update location failed due to conflict: {detail}\")\n        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=detail) from e\n</code></pre>"},{"location":"api/modules/locations/locations/#elims.api.modules.locations.schemas","title":"<code>schemas</code>","text":"<p>Schemas for the API locations module.</p>"},{"location":"api/modules/locations/locations/#elims.api.modules.locations.schemas.LocationBase","title":"<code>LocationBase</code>","text":"<p>               Bases: <code>SQLModel</code></p> <p>Base schema for a location with shared fields.</p>"},{"location":"api/modules/locations/locations/#elims.api.modules.locations.schemas.LocationCreate","title":"<code>LocationCreate</code>","text":"<p>               Bases: <code>LocationBase</code></p> <p>Schema for creating a new location (API input).</p>"},{"location":"api/modules/locations/locations/#elims.api.modules.locations.schemas.LocationRead","title":"<code>LocationRead</code>","text":"<p>               Bases: <code>LocationBase</code></p> <p>Schema for reading a location (API output).</p> <p>Includes the database-managed id field.</p>"},{"location":"api/modules/locations/locations/#elims.api.modules.locations.schemas.LocationUpdate","title":"<code>LocationUpdate</code>","text":"<p>               Bases: <code>SQLModel</code></p> <p>Schema for updating an existing location (API input).</p> <p>All fields are optional to allow for partial updates.</p>"},{"location":"api/modules/locations/locations/#elims.api.modules.locations.services","title":"<code>services</code>","text":"<p>Services for the API locations module.</p>"},{"location":"api/modules/locations/locations/#elims.api.modules.locations.services.LocationService","title":"<code>LocationService(session)</code>","text":"<p>Encapsulates CRUD operations for the Location model.</p> <p>Initialize the service with an async database session.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AsyncSession</code> <p>The asynchronous database session.</p> required Source code in <code>elims/api/modules/locations/services.py</code> <pre><code>def __init__(self, session: AsyncSession) -&gt; None:\n    \"\"\"Initialize the service with an async database session.\n\n    Args:\n        session: The asynchronous database session.\n\n    \"\"\"\n    self.session = session\n    logger.debug(f\"LocationService initialized with async session: {session}\")\n</code></pre>"},{"location":"api/modules/locations/locations/#elims.api.modules.locations.services.LocationService.create","title":"<code>create(location_data)</code>  <code>async</code>","text":"<p>Create a new location in the database.</p> <p>Parameters:</p> Name Type Description Default <code>location_data</code> <code>LocationCreate</code> <p>The data for the new location.</p> required <p>Returns:</p> Type Description <code>LocationRead</code> <p>The newly created location with its database ID.</p> <p>Raises:</p> Type Description <code>LocationAlreadyExistError</code> <p>If a location with the same address, postal_code, and city already exists.</p> Source code in <code>elims/api/modules/locations/services.py</code> <pre><code>async def create(self, location_data: LocationCreate) -&gt; LocationRead:\n    \"\"\"Create a new location in the database.\n\n    Args:\n        location_data: The data for the new location.\n\n    Returns:\n        The newly created location with its database ID.\n\n    Raises:\n        LocationAlreadyExistError: If a location with the same\n            address, postal_code, and city already exists.\n\n    \"\"\"\n    try:\n        location = Location.model_validate(location_data)\n        self.session.add(location)\n        await self.session.commit()\n        await self.session.refresh(location)\n        logger.info(f\"Created location with ID: {location.id}\")\n        return LocationRead.model_validate(location)\n    except IntegrityError as e:\n        await self.session.rollback()\n        logger.error(f\"Failed to create location: {e}\")\n        # Include address, postal_code, and city in error message to identify the composite key\n        location_identifier = f\"{location_data.address}, {location_data.postal_code}, {location_data.city}\"\n        raise LocationAlreadyExistError(location_identifier) from e\n</code></pre>"},{"location":"api/modules/locations/locations/#elims.api.modules.locations.services.LocationService.delete","title":"<code>delete(location_id)</code>  <code>async</code>","text":"<p>Delete a location from the database.</p> <p>Parameters:</p> Name Type Description Default <code>location_id</code> <code>int</code> <p>The ID of the location to delete.</p> required <p>Raises:</p> Type Description <code>LocationNotFoundError</code> <p>If no location with the given ID exists.</p> Source code in <code>elims/api/modules/locations/services.py</code> <pre><code>async def delete(self, location_id: int) -&gt; None:\n    \"\"\"Delete a location from the database.\n\n    Args:\n        location_id: The ID of the location to delete.\n\n    Raises:\n        LocationNotFoundError: If no location with the given ID exists.\n\n    \"\"\"\n    query = select(Location).where(Location.id == location_id)\n    result = await self.session.exec(query)\n    location = result.one_or_none()\n    if not location:\n        logger.warning(f\"Location with ID {location_id} not found for deletion.\")\n        raise LocationNotFoundError(location_id)\n\n    await self.session.delete(location)\n    await self.session.commit()\n    logger.info(f\"Deleted location with ID: {location_id}\")\n</code></pre>"},{"location":"api/modules/locations/locations/#elims.api.modules.locations.services.LocationService.get","title":"<code>get(location_id)</code>  <code>async</code>","text":"<p>Retrieve a location by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>location_id</code> <code>int</code> <p>The ID of the location to retrieve.</p> required <p>Returns:</p> Type Description <code>LocationRead</code> <p>The location with the specified ID.</p> <p>Raises:</p> Type Description <code>LocationNotFoundError</code> <p>If no location with the given ID exists.</p> Source code in <code>elims/api/modules/locations/services.py</code> <pre><code>async def get(self, location_id: int) -&gt; LocationRead:\n    \"\"\"Retrieve a location by its ID.\n\n    Args:\n        location_id: The ID of the location to retrieve.\n\n    Returns:\n        The location with the specified ID.\n\n    Raises:\n        LocationNotFoundError: If no location with the given ID exists.\n\n    \"\"\"\n    query = select(Location).where(Location.id == location_id)\n    result = await self.session.exec(query)\n    location = result.one_or_none()\n    if not location:\n        logger.warning(f\"Location with ID {location_id} not found.\")\n        raise LocationNotFoundError(location_id)\n    logger.debug(f\"Retrieved location with ID: {location_id}\")\n    return LocationRead.model_validate(location)\n</code></pre>"},{"location":"api/modules/locations/locations/#elims.api.modules.locations.services.LocationService.gets","title":"<code>gets()</code>  <code>async</code>","text":"<p>Retrieve all locations from the database.</p> <p>Returns:</p> Type Description <code>list[LocationRead]</code> <p>A list of all locations.</p> Source code in <code>elims/api/modules/locations/services.py</code> <pre><code>async def gets(self) -&gt; list[LocationRead]:\n    \"\"\"Retrieve all locations from the database.\n\n    Returns:\n        A list of all locations.\n\n    \"\"\"\n    query = select(Location)\n    result = await self.session.exec(query)\n    locations = result.all()\n    logger.info(f\"Retrieved {len(locations)} locations from the database.\")\n    return [LocationRead.model_validate(location) for location in locations]\n</code></pre>"},{"location":"api/modules/locations/locations/#elims.api.modules.locations.services.LocationService.update","title":"<code>update(location_id, location_data)</code>  <code>async</code>","text":"<p>Update an existing location in the database.</p> <p>Parameters:</p> Name Type Description Default <code>location_id</code> <code>int</code> <p>The ID of the location to update.</p> required <code>location_data</code> <code>LocationUpdate</code> <p>The updated data for the location.</p> required <p>Returns:</p> Type Description <code>LocationRead</code> <p>The updated location.</p> <p>Raises:</p> Type Description <code>LocationNotFoundError</code> <p>If no location with the given ID exists.</p> <code>LocationAlreadyExistError</code> <p>If the update would result in a duplicate address, postal_code, and city combination.</p> Source code in <code>elims/api/modules/locations/services.py</code> <pre><code>async def update(self, location_id: int, location_data: LocationUpdate) -&gt; LocationRead:\n    \"\"\"Update an existing location in the database.\n\n    Args:\n        location_id: The ID of the location to update.\n        location_data: The updated data for the location.\n\n    Returns:\n        The updated location.\n\n    Raises:\n        LocationNotFoundError: If no location with the given ID exists.\n        LocationAlreadyExistError: If the update would result in a duplicate\n            address, postal_code, and city combination.\n\n    \"\"\"\n    query = select(Location).where(Location.id == location_id)\n    result = await self.session.exec(query)\n    location = result.one_or_none()\n    if not location:\n        logger.warning(f\"Location with ID {location_id} not found for update.\")\n        raise LocationNotFoundError(location_id)\n\n    update_data = location_data.model_dump(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(location, key, value)\n\n    try:\n        self.session.add(location)\n        await self.session.commit()\n        await self.session.refresh(location)\n        logger.info(f\"Updated location with ID: {location_id}\")\n        return LocationRead.model_validate(location)\n    except IntegrityError as e:\n        await self.session.rollback()\n        logger.error(f\"Failed to update location with ID {location_id}: {e}\")\n        # Include composite key components in error message\n        address = update_data.get(\"address\", location.address)\n        postal_code = update_data.get(\"postal_code\", location.postal_code)\n        city = update_data.get(\"city\", location.city)\n        location_identifier = f\"{address}, {postal_code}, {city}\"\n        raise LocationAlreadyExistError(location_identifier) from e\n</code></pre>"}]}